# C++常见问题

### 1.指针和引用

指针和引用是编程中常用的概念，它们通常与内存地址和变量相关联。在C++和其他一些编程语言中，指针是一个存储了变量地址的变量，而引用则是一个已存在变量的别名。

- **指针**:
  - 指针是一个变量，其内部存储了另一个变量的内存地址。
  - 通过指针，可以直接访问或修改内存中的数据。
  - 指针需要进行解引用（使用`*`操作符）才能访问所指向的值。

- **引用**:
  - 引用是一个已存在变量的别名，它实际上并不占据额外的内存。
  - 通过引用，可以像使用原始变量一样访问数据，而无需使用解引用操作符。
  - 引用在创建时必须初始化，并且不能改变引用的目标。

这两个概念都在C++等语言中用于处理内存和函数参数传递等情况。指针通常更灵活，但也更容易出错，因为它们可以指向任何地方；而引用更安全，因为它们总是指向有效的对象。

### 2.指针和内存的关系

指针与内存之间有密切的关系，因为指针存储了变量或对象的内存地址，从而允许直接访问和操作内存中的数据。以下是指针与内存之间的关系：

1. **内存地址**：每个变量在计算机内存中都有一个唯一的地址，指针就是用来存储这些地址的变量。

2. **指针的值**：指针变量本身存储着另一个变量的内存地址，因此改变指针的值就意味着改变了它所指向的内存位置。

3. **指针的解引用**：通过解引用操作符`*`，可以访问指针所指向内存地址处的值，这样可以直接读取或修改内存中的数据。

4. **动态内存分配**：指针在动态内存分配中扮演重要角色，例如使用`new`（C++）或`malloc`（C）来分配内存，并使用`delete`（C++）或`free`（C）来释放内存。

5. **指针的生命周期管理**：程序员需要小心管理指针的生命周期，确保在不再需要时释放内存，以防止内存泄漏。

总之，指针允许直接操作内存，但也需要谨慎使用，因为错误的指针操作可能导致程序崩溃或安全漏洞。

### 3.程序编译过程，静态链接库和动态链接库

程序的编译过程通常包括以下几个步骤：

1. **预处理**：在这一阶段，预处理器会处理源代码，执行诸如宏替换、条件编译等操作，并生成经过预处理的中间代码。

2. **编译**：编译器将预处理后的代码转换为汇编语言或机器码。对于C++而言，这一步会将源代码翻译成目标文件。

3. **汇编**：汇编器将编译得到的汇编代码转换成可重定位的机器码，生成目标文件。

4. **链接**：链接器将目标文件与所需的库（静态或动态）结合，创建最终的可执行文件。

接下来，让我们深入了解一下静态链接库和动态链接库：

- **静态链接库**：
  - 静态链接库是在编译时被链接到程序中的库。
  - 它们以`.lib`（Windows）或`.a`（Unix/Linux）作为文件扩展名。
  - 链接器将库的代码和数据复制到最终可执行文件中，因此可执行文件会变得较大。
  - 静态链接库使得程序可以在没有额外依赖的情况下独立运行。

- **动态链接库**：
  - 动态链接库是在程序运行时被加载到内存中的库。
  - 它们以`.dll`（Windows）或`.so`（Unix/Linux）作为文件扩展名。
  - 程序在运行时需要动态链接库，但可执行文件本身较小。
  - 动态链接库可被多个程序共享，节省内存，并且允许动态升级和更新库。

总结起来，静态链接库在编译时被链接到程序中，而动态链接库则是在程序运行时被加载到内存中。选择使用哪种库取决于项目的具体需求和约束。

### 4.static、const、#define的用法和区别

`static`、`const` 和 `#define` 是在C++中经常使用的关键字和预处理器指令，它们用于不同的目的。以下是它们的用法和区别：

- **static**:
  - 在全局变量的情况下，`static` 使得变量仅在声明它的文件内可见，即具有文件作用域。
  - 在局部变量的情况下，`static` 使得变量在整个程序执行期间保持存在，而不是像普通局部变量那样在每次函数调用时创建和销毁。

- **const**:
  - `const` 用于声明常量，一旦赋值就不能再修改。
  - 它可以用于修饰变量，表示该变量的数值不可改变；也可以用于修饰函数参数，表示函数内部不会修改这些参数的值。

- **#define**:
  - `#define` 是一个预处理器指令，用于创建符号常量或简单的宏。
  - 通过 `#define` 可以定义常量、函数宏或条件编译宏。
  - 使用 `#define` 创建的符号常量在整个程序中都有效，但它们没有类型信息，只做简单的文本替换。

**区别**:

1. **作用域**:
   - `static` 可以限定变量的作用域（文件作用域或局部作用域）。
   - `const` 用于声明常量，不影响作用域。
   - `#define` 创建的符号常量在整个程序中都有效。

2. **类型信息**:
   - `const` 保留了数据类型信息，因为它实际上创建了一个只读变量。
   - `#define` 只是简单的文本替换，没有类型信息。
   - `static` 与类型信息无直接关联，主要用于控制作用域和生命周期。

3. **编译时处理**:
   - `const` 和 `static` 都在编译时处理。
   - `#define` 是预处理器指令，在编译前进行简单的文本替换。

总之，`static` 控制作用域和生命周期，`const` 声明常量，`#define` 创建符号常量或宏，并且它们各自有不同的特性和用途。

### 5.内存中的栈和堆分配

在计算机内存中，栈和堆是两种常见的内存分配方式，它们用于存储程序运行时所需的数据。以下是关于栈和堆分配的一些重要信息：

**栈分配**：
- 栈是一种后进先出（LIFO）的数据结构，用于存储函数调用时的局部变量、函数参数值、返回地址等。
- 当一个函数被调用时，该函数的参数和局部变量会被压入栈中；当函数执行完毕时，这些数据会自动弹出。
- 栈上分配的内存由编译器自动管理，因此它具有快速的分配和释放速度。
- 由于栈上的内存是自动管理的，因此它的生存期通常较短，超出作用域后将被自动释放。

**堆分配**：
- 堆是一种动态分配的内存区域，用于存储程序运行时需要动态分配的数据。
- 在堆上分配内存需要手动管理，程序员负责在适当的时候分配内存，并在不再需要时显式释放内存，以避免内存泄漏。
- 堆上分配的内存生存期比较灵活，可以在任意时刻进行分配和释放，因此它更适合存储动态大小的数据结构，如动态数组、对象等。
- 由于堆上的内存需要手动管理，因此存在内存泄漏和内存碎片化的风险，需要谨慎使用。

总结起来，栈用于存储函数调用时的局部数据，由编译器自动管理；而堆用于存储动态分配的数据，需要手动管理。选择使用栈还是堆取决于数据的生命周期、大小和复杂性等因素。

### 6.构造函数/析构函数/拷贝构造

构造函数、析构函数和拷贝构造函数是面向对象编程中与类相关的重要概念，它们分别用于对象的创建、销毁和复制。

##### **1. 构造函数**：

- 构造函数是一种特殊的成员函数，它在创建对象时被调用，用于初始化对象的数据成员。
- 构造函数的名称与类名相同，没有返回类型，可以有多个重载版本，包括默认构造函数、带参数的构造函数等。
- 当对象被创建时，构造函数会自动调用，用于初始化对象的状态。

```cpp
class MyClass {
public:
    // 默认构造函数
    MyClass() {
        // 初始化操作
    }

    // 带参数的构造函数
    MyClass(int value) {
        // 使用参数进行初始化
    }
};
```

##### **2.析构函数**：

- 析构函数用于在对象生命周期结束时执行清理工作，如释放资源、关闭文件等。
- 析构函数的名称是在类名前加上波浪号（~），没有参数和返回值。
- 当对象超出作用域、delete 操作符被调用或程序结束时，析构函数会自动调用。

```cpp
class MyClass {
public:
    // 析构函数
    ~MyClass() {
        // 清理操作
    }
};
```

##### **3.拷贝构造函数**：

- 拷贝构造函数用于创建一个新对象，其内容与另一个同类对象相同。
- 拷贝构造函数通常以引用方式传递参数，避免无限递归调用。
- 拷贝构造函数在以下情况下会被调用：使用一个对象来初始化同类的另一个对象、将对象作为参数传递给函数时（按值传递）等。

```cpp
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass &other) {
        // 复制 other 的内容到当前对象
    }
};
```

这些特殊的成员函数对于管理对象的生命周期、初始化和清理工作非常重要。合理定义和使用构造函数、析构函数和拷贝构造函数可以提高类的安全性、可维护性和灵活性。

### 7. C++的多态性

在 C++ 中，多态（polymorphism）是面向对象编程中的重要概念，允许将不同的派生类对象视为其基类对象，从而实现使用基类指针或引用调用派生类特定的函数。C++ 中的多态性主要通过虚函数和纯虚函数实现。

##### 1.虚函数（virtual functions）：

- 在基类中声明的虚函数可以在派生类中被重写（override）。
- 通过将基类指针或引用指向派生类对象，可以实现运行时多态性，即在运行时确定调用的函数版本。
- 要声明一个虚函数，在函数声明前加上 virtual 关键字，在基类和派生类中都需要声明为虚函数。

示例：

```C++
class Base {
public:
    virtual void print() {
        std::cout << "Base class print function\n";
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class print function\n";
    }
};

int main() {
    Base* ptr = new Derived();
    ptr->print(); // 调用 Derived 类中的 print 函数
    delete ptr;
    return 0;
}
```

##### 2.纯虚函数（pure virtual functions）：

- 纯虚函数是在基类中声明的虚函数，但没有提供具体的实现，只有函数声明，通过在函数声明后加上 = 0 来声明纯虚函数。
- 拥有纯虚函数的类称为抽象类，不能被实例化，只能作为基类使用。
- 派生类必须实现基类的纯虚函数，才能成为一个具体的类。

示例：

```c++
class AbstractBase {
public:
    virtual void draw() = 0; // 纯虚函数
};

class ConcreteDerived : public AbstractBase {
public:
    void draw() override {
        std::cout << "Drawing in ConcreteDerived class\n";
    }
};

int main() {
    AbstractBase* ptr = new ConcreteDerived();
    ptr->draw(); // 调用 ConcreteDerived 类中的 draw 函数
    delete ptr;
    return 0;
}
```

通过虚函数和纯虚函数，C++ 实现了多态性，让代码更具灵活性和可扩展性。

### 8.内存泄漏

内存泄漏指的是程序在动态分配内存后，未能正确释放或回收该内存造成的问题。内存泄漏可能会导致程序运行时占用的内存不断增加，最终导致系统性能下降甚至崩溃。

- 常见导致内存泄漏的情况包括：

未释放动态分配的内存：例如使用 new 关键字分配内存后，没有使用 delete 进行释放。
循环引用：如果对象之间存在循环引用，并且没有正确处理，可能导致对象无法被销毁。

```C++
#include <memory>
using namespace std;

class Node {
public:
    shared_ptr<Node> next;
};

void create_cycle() {
    shared_ptr<Node> node1 = make_shared<Node>();
    shared_ptr<Node> node2 = make_shared<Node>();
    node1->next = node2;
    node2->next = node1; // 循环引用
}
```

 全局变量和静态变量：全局变量或静态变量指向动态分配的内存，且未在程序结束时释放。

```c++
int* global_ptr = nullptr;

void init_global() {
    global_ptr = new int[100];
}

int main() {
    init_global();
    // 忘记释放 global_ptr 指向的内存
    return 0;
}
```

指针丢失：当动态分配的内存地址保存在某个指针中，但后续对该指针进行重新赋值而未释放原内存时，就会发生内存泄漏。
缓存未释放：一些缓存机制可能导致对象被频繁创建但未被正确清理，从而造成内存泄漏。
异常情况下的内存泄漏：如果程序在处理异常情况时没有正确释放内存，也可能导致内存泄漏。

```c++
void risky_function() {
    int* ptr = new int[100];
    try {
        // 可能抛出异常的代码
    } catch (...) {
        // 忘记释放 ptr 指向的内存
        throw;
    }
    delete[] ptr; // 只有在没有异常的情况下才会执行
}
```

- 避免内存泄漏的方法包括：

正确管理动态内存：使用 new 后要及时使用 delete 或者智能指针（如 std::unique_ptr、std::shared_ptr）来管理内存。
避免循环引用：尽量避免对象之间存在循环引用，或者使用弱引用（weak reference）来打破循环引用。
谨慎使用全局变量：全局变量可能导致程序结束时未释放内存，应该尽量避免过多使用全局变量。
注意异常处理：确保在异常发生时正确释放内存，可以使用 RAII（资源获取即初始化）等技术来自动管理资源的释放。

### 9.智能指针

智能指针是 C++ 中用于管理动态内存的一种机制，它可以自动管理内存的生命周期，避免内存泄漏和悬空指针等问题。C++11 引入了三种主要类型的智能指针：std::unique_ptr、std::shared_ptr 和 std::weak_ptr。

##### 1.std::unique_ptr：

std::unique_ptr 是独占所有权的智能指针，不允许多个指针共享同一个对象。
当 std::unique_ptr 被销毁或者赋予新的值时，它所管理的对象会被自动释放。
可以使用 std::move 来转移 std::unique_ptr 的所有权。
适用于**需要独占所有权**的情况，例如资源管理类对象。
示例：

```C++
std::unique_ptr<int> ptr(new int(42));
// 使用 unique_ptr，无需手动释放内存
```

##### 2.std::shared_ptr：

std::shared_ptr 允许多个智能指针共享同一个对象，使用引用计数来管理对象的生命周期。

当最后一个指向对象的 std::shared_ptr 被销毁时，对象会被自动释放。
可以使用 std::make_shared 来创建 std::shared_ptr。
适用于需要**多个指针共享对象所有权**的情况。
示例：

```C++
std::shared_ptr<int> ptr = std::make_shared<int>(42);
// 多个 shared_ptr 共享同一个对象
```

##### 3.std::weak_ptr：

std::weak_ptr 是 std::shared_ptr 的弱引用，不影响对象的引用计数。
可以通过 std::weak_ptr 来解决 std::shared_ptr 的循环引用问题。
使用 lock() 方法可以获得一个指向对象的 std::shared_ptr。
适用于需要观察 std::shared_ptr 对象但不拥有所有权的情况。
示例：

```C++
std::shared_ptr<int> shared = std::make_shared<int>(42);
std::weak_ptr<int> weak = shared;
if (auto ptr = weak.lock()) {
    // 使用 ptr 操作对象
}
```



### 10.->和.的区别与联系

在 C++ 中，.op() 和 ->op 是访问成员函数的两种不同方式。这两种方式都用于调用一个对象的成员函数，但它们有不同的使用场景。

->op 通常用于访问指向对象的指针的成员函数。例如，如果有一个指向类对象的指针，可以使用 -> 运算符来访问该对象的成员函数。例如：

```C++
MyClass* obj = new MyClass();
obj->myMethod();
```

上面的代码创建了一个 MyClass 的对象，并使用指向该对象的指针 obj 来调用 myMethod 函数。

. op() 则用于直接访问对象的成员函数。例如，如果有一个 MyClass 的对象，可以使用 . 运算符来访问该对象的成员函数。例如：

```C++
MyClass obj;
obj.myMethod();
```

上面的代码创建了一个 MyClass 的对象 obj，并直接使用 obj 来调用 myMethod 函数。

需要注意的是，如果使用指向对象的引用来访问对象的成员函数，则应该使用 . 运算符。因为指向对象的引用本身就是一个对象的别名，所以不能使用 -> 运算符。例如：

```C++
MyClass& objRef = obj;
objRef.myMethod();
```

### 11.动态库和静态库

.a文件是静态库（Static Library）的文件扩展名，而 .so 文件是共享对象（Shared Object）或动态链接库（Dynamic Library）的文件扩展名。

静态库（.a 文件）：
静态库是一组已经编译好的目标文件（Object File）的集合，这些目标文件包含了函数和数据，它们被组合成一个单独的文件。在链接阶段，编译器会将静态库中的目标文件直接复制到可执行文件中，因此可执行文件中包含了所有静态库中的函数和数据。静态库在编译时被链接到程序中，因此程序在运行时不需要外部的依赖。

动态库（.so 文件）：
动态库是一组已经编译好的目标文件的集合，但它们不会被直接复制到可执行文件中。相反，可执行文件包含了对动态库的引用，这些引用在程序运行时动态地解析并链接到系统中的共享库。这意味着多个程序可以共享同一个动态库的副本，从而节省内存空间。动态库在运行时被加载到内存中，并且可以通过重新链接动态库或者替换动态库的版本来更新功能或修复 bug。

通常情况下，使用静态库意味着你的可执行文件会比较大，因为它包含了静态库中所有的函数和数据。而使用动态库则可以减小可执行文件的大小，并且提供了更好的灵活性和易于维护性。

在编译和链接程序时，你可以选择是链接静态库还是动态库，这取决于你的需求和项目的具体情况。



### 12. C++11,14,17

#### C++11
- **年份**：2011年
- **主要特点**：
  - 自动类型推导（`auto`关键字）
  - 基于范围的for循环（range-based for loop）
  - lambda表达式
  - 智能指针（如`std::unique_ptr`和`std::shared_ptr`）
  - 右值引用和移动语义（包括`std::move`和`&&`操作符）
  - 统一的初始化列表（Uniform Initialization）
  - 多线程支持（通过 `<thread>`, `<mutex>`, `<atomic>` 等库）

#### C++14
- **年份**：2014年
- **主要特点**（在C++11的基础上）：
  - 二进制字面量（例如`0b1010`）
  - 泛型lambda表达式
  - 可变模板参数（`auto`在模板参数中的应用）
  - 改进的类型推导（例如，`decltype(auto)`）
  - 标准库中新的函数，如`std::make_unique`
  - 对右值引用的改进，如`std::move`的返回类型

#### C++17
- **年份**：2017年
- **主要特点**（在C++14的基础上）：
  - 结构化绑定（Structured Bindings）
  - if constexpr（条件编译）
  - 嵌套命名空间规范（`inline namespace`）
  - 标准库中新的并行算法（如`std::for_each`的并行版本）
  - 可选类型（`std::optional`）
  - 变体类型（`std::variant`）
  - 标准库中新的文件系统库（`<filesystem>`）
  - 改进的lambda表达式语法

每个新版本的C++都旨在提高语言的表达能力、性能和易用性。开发者通常会根据项目需求和编译器支持情况选择使用哪个版本的C++标准。随着C++20的发布，C++语言继续引入了更多的现代化特性，如概念（concepts）、协程（coroutines）和模块（modules）。



### 13. C和C++的区别

C++与C的主要区别在于它们的编程范式、语法特性、类型检查机制、面向对象编程支持、标准库以及兼容性。1

编程范式：C语言是一种过程式编程语言，强调面向过程的编程方式，主要关注函数的设计和调用；而C++语言是一种面向对象的编程语言，支持面向对象的编程范式，包括类、对象、继承、封装、多态等概念。

语法特性：C++是在C语言的基础上进行扩展和增强的，因此C++语法上兼容C语言，但也引入了许多新的语法特性，如类、对象、命名空间、模板、异常处理等，这些在C语言中是不存在的。

类型检查：C++语言具有更严格的类型检查机制，支持强类型的编程，对数据类型的转换更加严格；而C语言对类型的检查较为宽松，允许进行一些隐式的类型转换。

面向对象编程(OOP)支持：C++是一种支持面向对象编程的语言，提供了类、对象、继承、多态等面向对象编程的特性；而C语言不支持面向对象编程，仅支持过程式编程。

标准库：C++标准库包含了C语言标准库的功能，并且在此基础上增加了许多面向对象编程的特性，例如STL(Standard Template Library)等；而C语言标准库仅包含了基本的C语言函数库。

兼容性：C++语言是在C语言的基础上进行扩展和增强的，因此C++代码可以直接调用C语言的代码；而C语言不支持C++的一些语法特性，C++代码在C语言环境中无法编译和运行。

总的来说，C语言和C++语言有着不同的编程范式、语法特性、类型检查机制、面向对象编程支持、标准库等方面的区别。C++是在C语言的基础上进行扩展和增强的，支持更多的编程范式和特性，特别适合面向对象编程。而C语言则是一种更为简洁和基础的编程语言，适合于需要较低层次的系统编程和嵌入式系统开发。

###  14. C++存储区域

栈区,堆区,全局区,常量区,代码区

<img src="/run/user/1000/gvfs/smb-share:server=10.1.1.57,share=ic-users/算法部/cywang/qu.png" alt="qu" style="zoom:200%;" />

| 内容             | 内存影像区           | 权限 |
| ---------------- | -------------------- | ---- |
| 栈区             | 函数中的普通变量     | rw   |
| 堆区             | 动态申请的内存       | rw   |
| (全局)静态变量区 | static修饰的变量     | rw   |
| 常量区           | 用于初始化变量的常量 | r    |
| 代码区           | 代码指令             | r    |

### 15. 面向对象的三大特性：封装、继承、多态

C++是一种支持面向对象编程（OOP）的语言，其三大特性是封装、继承和多态，这些特性共同构成了面向对象设计的核心概念。

封装（Encapsulation）：

封装是将对象的数据（属性）和行为（方法）组合在一起的过程，同时隐藏内部的实现细节，只暴露出一个可以被外界访问的接口。
通过使用访问修饰符（如 private、protected 和 public）来控制成员变量和成员函数的可见性，确保对象的内部状态不被外部直接修改，从而提高安全性和易于维护。

继承（Inheritance）：

继承是一种机制，允许一个类（称为子类或派生类）继承另一个类（称为基类或父类）的属性和方法，而无需重新编写代码。
继承支持代码复用，并可以创建出一个层次结构，子类可以扩展或修改基类的行为。
C++支持单继承、多继承和虚拟继承，其中单继承指一个类只继承自一个父类，多继承指一个类继承自多个父类，虚拟继承用于解决多继承中的菱形继承问题。

多态（Polymorphism）：

多态是指对象可以有多种形式的能力，允许不同类的对象对同一消息做出响应，但响应的方式取决于对象的实际类型。
C++通过虚函数（virtual functions）实现多态。当基类中定义了一个虚函数时，派生类可以重写（override）该函数，提供特定的实现。
多态还允许使用基类指针或引用来指向派生类的对象，这样可以通过基类的接口调用派生类的方法，实现动态绑定（晚期绑定）。
这三大特性使得C++能够有效地支持面向对象的设计原则，如抽象、封装、继承和多态，从而促进了代码的模块化、重用和可维护性。

### 16.拷贝构造函数和移动构造函数

移动构造函数和拷贝构造函数都是C++中构造函数的特化形式，它们在对象的生命周期中扮演不同的角色，特别是在资源管理方面。以下是移动构造函数和拷贝构造函数的对比：

1. **目的**：
   - **拷贝构造函数**：用于创建一个对象的副本，即用一个已存在的对象来初始化一个新对象。
   - **移动构造函数**：用于在不拷贝资源的情况下，将资源从一个对象转移到另一个新对象。

2. **参数**：
   - **拷贝构造函数**：接受一个该类类型的常量引用作为参数。
   - **移动构造函数**：接受一个该类类型的右值引用（使用`std::move`）作为参数。

3. **行为**：
   - **拷贝构造函数**：执行成员逐一拷贝（member-wise copy），如果对象管理资源（如动态内存），则为新对象分配新的资源。
   - **移动构造函数**：将资源的所有权从一个对象转移到另一个对象，不进行拷贝，通常涉及到资源的转移。

4. **效率**：
   - **拷贝构造函数**：可能会涉及昂贵的资源拷贝操作，特别是当对象包含大型数据结构或资源时。
   - **移动构造函数**：通常更高效，因为它避免了拷贝成本，直接转移资源。

5. **使用场景**：
   - **拷贝构造函数**：当你需要一个对象的精确副本时使用。
   - **移动构造函数**：当你想要避免拷贝成本，或者当对象作为临时对象（如函数返回值或标准库容器的元素）传递时使用。

6. **示例代码**：
   - 拷贝构造函数：
     ```cpp
     class MyClass {
     public:
         MyClass(const MyClass& other) : member(other.member) {}
         // ...
     };
     ```
   - 移动构造函数：
     ```cpp
     class MyClass {
     public:
         MyClass(MyClass&& other) noexcept : member(std::move(other.member)) {}
         // ...
     };
     ```

7. **`noexcept` 说明**：
   - 移动构造函数通常声明为 `noexcept`，表示它不会抛出异常，这是因为移动构造函数只是资源的转移，理论上不应该失败。

8. **C++11 特性**：
   - 移动构造函数是在C++11中引入的，与右值引用和移动语义一起，它们为资源管理提供了更灵活和高效的方式。

总结来说，拷贝构造函数用于创建对象的副本，而移动构造函数用于在对象间转移资源，通常用于避免不必要的资源拷贝，特别是在涉及到临时对象或者资源密集型对象时。

### 17.深拷贝和浅拷贝

![copy](/run/user/1000/gvfs/smb-share:server=10.1.1.57,share=ic-users/算法部/cywang/copy.png)

深拷贝（Deep Copy）与浅拷贝（Shallow Copy）是编程中两种不同的拷贝行为，特别是在涉及到对象的资源管理时，它们的区别尤为重要。以下是深拷贝和浅拷贝的主要区别：

1. **拷贝内容**：
   - **深拷贝**：创建原始对象的一个完全独立的副本，包括它所管理的所有资源。这意味着如果原始对象包含指针或其他引用指向动态分配的内存，深拷贝会为副本分配新的内存，并复制所有相关的数据。
   - **浅拷贝**：只复制对象本身，不复制它所管理的资源。如果对象包含指针，浅拷贝只会复制这些指针的值，而不是它们指向的数据。

2. **资源管理**：
   
   - 深拷贝确保原始对象和副本对象拥有独立的资源，因此它们之间不会相互影响。
   - 浅拷贝可能导致原始对象和副本对象共享资源，这可能会引起管理上的问题，如重复释放同一资源。
   
3. **内存分配**：
   - 深拷贝需要为副本分配新的内存，如果对象包含动态分配的资源，深拷贝会复制这些资源。
   - 浅拷贝不涉及新的内存分配，它只复制原始对象的成员值。

4. **使用场景**：
   - 深拷贝通常用于当你需要一个对象的完整副本，且副本对象的生命周期与原始对象无关时。
   - 浅拷贝通常用于对象的生命周期短，或者对象的副本不需要独立管理资源时。

5. **效率**：
   
   - 深拷贝可能更耗时，因为它需要复制所有资源，特别是当对象包含大量数据时。
   - 浅拷贝通常更快，因为它只复制对象的引用或指针。
   
6. **示例代码**：
   - 浅拷贝示例（成员逐一复制）：
     ```cpp
     class MyClass {
     public:
         int* data;
          MyClass() : data(new int[10]) {}
         // 浅拷贝构造函数
         MyClass(const MyClass& other) : arraySize(other.arraySize), data(other.data) {
             // 这里只是复制了指针，没有复制数据
         }
     };
     ```
   - 深拷贝示例（使用标准库函数或拷贝构造函数）：
     ```cpp
     class MyClass {
     public:
         int* data;
          MyClass() : data(new int[10]) {}
           // 深拷贝构造函数
         MyClass(const MyClass& other) {
             data = new int[10];
             std::copy(other.data, other.data + 10, data); // 复制数据到新分配的内存
     };
     ```
   
         1.C++统默认的拷贝构造函数是: 浅拷贝。
         2.当类中有指针类型的成员时，才去考虑深拷贝和浅拷贝的问题。

### 18.空类

在C++中，一个"空类"（Empty Class）指的是一个没有任何数据成员的类。空类的大小理论上应该是0字节，但是实际上，由于不同编译器的实现和底层硬件的对齐要求，空类的大小可能会是1字节或更大，以满足内存对齐的要求。内存对齐是为了优化访问速度，编译器会根据平台的对齐要求来调整类的大小。

空类示例：
```cpp
class EmptyClass {
};
```

一个空类默认会包含以下几个成员函数：

1. **默认构造函数**（Default Constructor）：
   - 如果用户没有定义任何构造函数，编译器会隐式地提供一个默认构造函数。
2. **拷贝构造函数**（Copy Constructor）：
   - 同样，如果用户没有定义，编译器会提供一个默认的拷贝构造函数。
3. **移动构造函数**（Move Constructor）：
   - C++11及以后的版本中，如果没有定义移动构造函数，编译器也会提供一个。
4. **拷贝赋值运算符**（Copy Assignment Operator）：
   - 默认的拷贝赋值运算符，如果没有用户定义的版本。
5. **移动赋值运算符**（Move Assignment Operator）：
   - 默认的移动赋值运算符，同样在C++11及以后的版本中提供。
6. **析构函数**（Destructor）：
   - 一个默认的析构函数，即使类是空的。

空类的大小示例：
```cpp
#include <iostream>

class EmptyClass {
};

int main() {
    std::cout << "Size of EmptyClass: " << sizeof(EmptyClass) << std::endl;
    return 0;
}
```
当你运行这段代码时，输出的`Size of EmptyClass`可能是1字节，也可能是更大的数值，这取决于编译器和平台的内存对齐要求。

如果你想要确保一个类的大小为1字节，可以在类中添加一个`char`类型的成员变量，这样编译器就不太可能增加额外的填充字节了：
```cpp
class SizedClass {
    char dummy;
};
```
这样，`SizedClass`的大小将至少是`sizeof(char)`，通常是1字节。
